<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --color-primary: #208494;
            --color-secondary: #6b5b95;
            --color-highlight: #ff6b6b;
            --color-sorted: #51cf66;
            --color-unsorted: #4dabf7;
            --color-bg: #1a1a1a;
            --color-surface: #2d2d2d;
            --color-text: #e9ecef;
            --color-border: #495057;
        }

        body {
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: var(--color-primary);
        }

        .header p {
            font-size: 1.1em;
            color: #adb5bd;
        }

        .controls {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: auto auto auto auto auto 1fr;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.9em;
            font-weight: 500;
            color: #adb5bd;
        }

        select, input {
            background-color: var(--color-bg);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover, input:hover {
            border-color: var(--color-primary);
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(32, 132, 148, 0.2);
        }

        button {
            background-color: var(--color-primary);
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        button:hover {
            background-color: #1a6b82;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats {
            margin-left: auto;
            display: flex;
            gap: 30px;
            padding-left: 20px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stat-label {
            font-size: 0.85em;
            color: #adb5bd;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--color-primary);
            font-family: 'Courier New', monospace;
        }

        .visualization {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 30px;
            height: 500px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 3px;
        }

        .array-container {
            display: flex;
            align-items: flex-end;
            gap: 3px;
            width: 100%;
            height: 100%;
            justify-content: space-around;
        }

        .bar {
            background: linear-gradient(180deg, var(--color-unsorted), #2d5f7a);
            border-radius: 4px 4px 0 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            min-width: 8px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }

        .bar.active {
            background: linear-gradient(180deg, var(--color-highlight), #d32f2f);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.6);
        }

        .bar.sorted {
            background: linear-gradient(180deg, var(--color-sorted), #2b5f3f);
        }

        .bar.comparing {
            background: linear-gradient(180deg, var(--color-highlight), #ff5252);
        }

        .code-section {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
        }

        .code-display {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .code-line {
            padding: 2px 8px;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
            position: relative;
        }

        .code-line-number {
            display: inline-block;
            width: 35px;
            color: #666;
            user-select: none;
            margin-right: 10px;
            text-align: right;
        }

        .code-line.executing {
            background-color: rgba(32, 132, 148, 0.3);
            border-left-color: var(--color-primary);
            color: var(--color-primary);
            font-weight: 600;
        }

        .info-section {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
        }

        .info-section h3 {
            color: var(--color-primary);
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .info-item {
            padding: 15px;
            background-color: var(--color-bg);
            border-left: 3px solid var(--color-primary);
            border-radius: 6px;
        }

        .info-item strong {
            color: var(--color-primary);
        }

        .complexity-display {
            background-color: var(--color-bg);
            border-left: 3px solid var(--color-primary);
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 1.05em;
        }

        .viz-code-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .code-execution-block {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .code-execution-block h3 {
            margin: 0 0 15px 0;
            color: var(--color-primary);
            font-size: 1.1em;
        }

        .code-execution-footer {
            color: #adb5bd;
            font-size: 0.9em;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
        }

        .code-execution-footer strong {
            color: var(--color-text);
        }

        .code-execution-footer span {
            color: var(--color-primary);
            font-family: monospace;
        }

        @media (max-width: 1200px) {
            .controls {
                grid-template-columns: repeat(2, auto);
            }
            .stats {
                margin-left: 0;
                margin-top: 15px;
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 968px) {
            .viz-code-grid {
                grid-template-columns: 1fr;
            }
            
            .code-execution-block {
                order: 2;
            }
            
            .visualization {
                height: 350px;
            }
        }

        @media (max-width: 768px) {
            .visualization {
                height: 300px;
            }
            .controls {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            .stats {
                flex-direction: column;
                gap: 10px;
            }
            
            .code-display {
                max-height: 300px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .visualization {
                height: 250px;
                padding: 15px;
            }
            
            .code-execution-block {
                padding: 15px;
            }
            
            .code-display {
                max-height: 250px;
                font-size: 0.85em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¨ Algorithm Visualizer</h1>
            <p>Watch sorting and searching algorithms come to life</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="algorithm">Algorithm</label>
                <select id="algorithm">
                    <option value="bubble">Bubble Sort</option>
                    <option value="selection">Selection Sort</option>
                    <option value="insertion">Insertion Sort</option>
                    <option value="merge">Merge Sort</option>
                    <option value="quick">Quick Sort</option>
                </select>
            </div>

            <div class="control-group">
                <label for="arraySize">Array Size</label>
                <input type="range" id="arraySize" min="10" max="100" value="50">
                <span id="arraySizeDisplay">50</span>
            </div>

            <div class="control-group">
                <label for="speed">Speed (ms)</label>
                <input type="range" id="speed" min="100" max="1000" step="100" value="100">
                <span id="speedDisplay">100</span>
            </div>

            <button id="generateBtn">Generate Array</button>
            <button id="startBtn">Start Sorting</button>
            <button id="resetBtn">Reset</button>

            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Comparisons</span>
                    <span class="stat-value" id="comparisons">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Swaps</span>
                    <span class="stat-value" id="swaps">0</span>
                </div>
            </div>
        </div>

        <div class="viz-code-grid">
            <div class="visualization">
                <div class="array-container" id="arrayContainer"></div>
            </div>
            <div class="code-execution-block">
                <h3>Code Execution</h3>
                <div class="code-display" id="codeDisplay"></div>
                <div class="code-execution-footer">
                    <strong>Line:</strong> <span id="lineNumber">â€”</span>
                </div>
            </div>
        </div>

        <div class="info-section">
            <h3 id="algorithmName">Bubble Sort</h3>
            <div class="info-grid" id="complexityGrid">
                <div class="info-item">
                    <strong>Time Complexity:</strong>
                    <div class="complexity-display" id="timeComplexity">O(nÂ²)</div>
                </div>
                <div class="info-item">
                    <strong>Space Complexity:</strong>
                    <div class="complexity-display" id="spaceComplexity">O(1)</div>
                </div>
                <div class="info-item">
                    <strong>Status:</strong>
                    <div id="status">Ready to sort</div>
                </div>
            </div>
            <div class="info-item" style="margin-top: 15px;">
                <strong>Description:</strong>
                <div id="algorithmDesc" style="margin-top: 8px; line-height: 1.6;"></div>
            </div>
        </div>
    </div>

    <script>
        const algorithmCode = {
            bubble: `function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      // Compare adjacent elements
      if (arr[j] > arr[j + 1]) {
        // Swap if wrong order
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}`,
            selection: `function selectionSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let minIdx = i;
    for (let j = i + 1; j < n; j++) {
      // Find minimum element
      if (arr[j] < arr[minIdx]) {
        minIdx = j;
      }
    }
    // Swap with current position
    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
  }
  return arr;
}`,
            insertion: `function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let key = arr[i];
    let j = i - 1;
    // Shift larger elements right
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    // Insert key at correct position
    arr[j + 1] = key;
  }
  return arr;
}`,
            merge: `function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  
  // Merge sorted halves
  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  return result.concat(left, right);
}`,
            quick: `function quickSort(arr) {
  if (arr.length <= 1) return arr;
  
  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter(x => x < pivot);
  const middle = arr.filter(x => x === pivot);
  const right = arr.filter(x => x > pivot);
  
  // Recursively sort and combine
  return quickSort(left)
    .concat(middle, quickSort(right));
}`
        };

        const algorithms = {
            bubble: {
                name: 'Bubble Sort',
                complexity: { time: 'O(nÂ²)', space: 'O(1)' },
                description: 'Repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The largest element "bubbles up" to the end with each pass.',
                sort: bubbleSort
            },
            selection: {
                name: 'Selection Sort',
                complexity: { time: 'O(nÂ²)', space: 'O(1)' },
                description: 'Divides the array into sorted and unsorted regions. Repeatedly finds the minimum element from the unsorted region and moves it to the sorted region.',
                sort: selectionSort
            },
            insertion: {
                name: 'Insertion Sort',
                complexity: { time: 'O(nÂ²)', space: 'O(1)' },
                description: 'Builds the sorted array one item at a time. Takes each element and inserts it into its correct position in the already-sorted portion of the array.',
                sort: insertionSort
            },
            merge: {
                name: 'Merge Sort',
                complexity: { time: 'O(n log n)', space: 'O(n)' },
                description: 'A divide-and-conquer algorithm that divides the array into halves, recursively sorts them, and then merges the sorted halves together.',
                sort: mergeSort
            },
            quick: {
                name: 'Quick Sort',
                complexity: { time: 'O(n log n)', space: 'O(log n)' },
                description: 'A divide-and-conquer algorithm that selects a pivot element and partitions the array around it, then recursively sorts the sub-arrays.',
                sort: quickSort
            }
        };

        let array = [];
        let comparisons = 0;
        let swaps = 0;
        let isSorting = false;
        let currentLine = null;

        const elements = {
            arrayContainer: document.getElementById('arrayContainer'),
            algorithm: document.getElementById('algorithm'),
            arraySize: document.getElementById('arraySize'),
            speed: document.getElementById('speed'),
            generateBtn: document.getElementById('generateBtn'),
            startBtn: document.getElementById('startBtn'),
            resetBtn: document.getElementById('resetBtn'),
            comparisons: document.getElementById('comparisons'),
            swaps: document.getElementById('swaps'),
            algorithmName: document.getElementById('algorithmName'),
            timeComplexity: document.getElementById('timeComplexity'),
            spaceComplexity: document.getElementById('spaceComplexity'),
            algorithmDesc: document.getElementById('algorithmDesc'),
            status: document.getElementById('status'),
            codeDisplay: document.getElementById('codeDisplay'),
            lineNumber: document.getElementById('lineNumber')
        };

        // Initialize
        elements.algorithm.addEventListener('change', () => {
            updateAlgorithmInfo();
            displayCode();
        });
        elements.arraySize.addEventListener('input', (e) => {
            document.getElementById('arraySizeDisplay').textContent = e.target.value;
        });
        elements.speed.addEventListener('input', (e) => {
            document.getElementById('speedDisplay').textContent = e.target.value;
        });
        elements.generateBtn.addEventListener('click', generateArray);
        elements.startBtn.addEventListener('click', startSorting);
        elements.resetBtn.addEventListener('click', reset);

        updateAlgorithmInfo();
        displayCode();
        generateArray();

        function displayCode() {
            const algoCode = algorithmCode[elements.algorithm.value];
            const lines = algoCode.split('\n');
            elements.codeDisplay.innerHTML = lines
                .map((line, idx) => `
                    <div class="code-line" data-line="${idx + 1}">
                        <span class="code-line-number">${idx + 1}</span>
                        <span>${escapeHtml(line)}</span>
                    </div>
                `)
                .join('');
        }

        function escapeHtml(text) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        function highlightLine(lineNum) {
            document.querySelectorAll('.code-line').forEach(el => {
                el.classList.remove('executing');
            });
            if (lineNum !== null) {
                const line = document.querySelector(`[data-line="${lineNum}"]`);
                if (line) {
                    line.classList.add('executing');
                    line.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            elements.lineNumber.textContent = lineNum || 'â€”';
        }

        function generateArray() {
            const size = parseInt(elements.arraySize.value);
            array = Array.from({ length: size }, () => Math.floor(Math.random() * 100) + 1);
            renderArray(array);
            resetStats();
        }

        function renderArray(arr, activeIndices = [], sortedIndices = []) {
            elements.arrayContainer.innerHTML = '';
            const maxValue = Math.max(...arr);
            
            arr.forEach((value, idx) => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = (value / maxValue) * 100 + '%';
                
                if (sortedIndices.includes(idx)) {
                    bar.classList.add('sorted');
                } else if (activeIndices.includes(idx)) {
                    bar.classList.add('comparing');
                }
                
                elements.arrayContainer.appendChild(bar);
            });
        }

        function updateAlgorithmInfo() {
            const algo = algorithms[elements.algorithm.value];
            elements.algorithmName.textContent = algo.name;
            elements.timeComplexity.textContent = algo.complexity.time;
            elements.spaceComplexity.textContent = algo.complexity.space;
            elements.algorithmDesc.textContent = algo.description;
        }

        function resetStats() {
            comparisons = 0;
            swaps = 0;
            updateStats();
        }

        function updateStats() {
            elements.comparisons.textContent = comparisons;
            elements.swaps.textContent = swaps;
        }

        async function startSorting() {
            if (isSorting) return;
            isSorting = true;
            elements.startBtn.disabled = true;
            elements.generateBtn.disabled = true;
            elements.arraySize.disabled = true;
            elements.algorithm.disabled = true;
            resetStats();

            const algo = algorithms[elements.algorithm.value];
            await algo.sort([...array]);

            elements.status.textContent = 'Sorting complete! âœ“';
            isSorting = false;
            elements.startBtn.disabled = false;
            elements.generateBtn.disabled = false;
            elements.arraySize.disabled = false;
            elements.algorithm.disabled = false;
        }

        function reset() {
            location.reload();
        }

        async function sleep() {
            return new Promise(resolve => setTimeout(resolve, parseInt(elements.speed.value)));
        }

        // Sorting Algorithms
        async function bubbleSort(arr) {
            const n = arr.length;
            highlightLine(2);
            await sleep();
            for (let i = 0; i < n; i++) {
                highlightLine(3);
                await sleep();
                for (let j = 0; j < n - i - 1; j++) {
                    highlightLine(4);
                    await sleep();
                    comparisons++;
                    updateStats();
                    renderArray(arr, [j, j + 1], Array.from({ length: n - i }, (_, k) => n - 1 - k));

                    highlightLine(6);
                    await sleep();
                    if (arr[j] > arr[j + 1]) {
                        highlightLine(8);
                        await sleep();
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        swaps++;
                        updateStats();
                    }
                }
            }
            highlightLine(null);
            renderArray(arr, [], Array.from({ length: n }, (_, i) => i));
        }

        async function selectionSort(arr) {
            const n = arr.length;
            highlightLine(2);
            await sleep();
            for (let i = 0; i < n - 1; i++) {
                highlightLine(3);
                await sleep();
                let minIdx = i;
                highlightLine(4);
                await sleep();
                for (let j = i + 1; j < n; j++) {
                    highlightLine(5);
                    await sleep();
                    comparisons++;
                    updateStats();
                    renderArray(arr, [i, j], Array.from({ length: i }, (_, k) => k));

                    highlightLine(6);
                    await sleep();
                    if (arr[j] < arr[minIdx]) {
                        highlightLine(7);
                        await sleep();
                        minIdx = j;
                    }
                }
                highlightLine(11);
                await sleep();
                if (minIdx !== i) {
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    swaps++;
                    updateStats();
                }
            }
            highlightLine(null);
            renderArray(arr, [], Array.from({ length: n }, (_, i) => i));
        }

        async function insertionSort(arr) {
            for (let i = 1; i < arr.length; i++) {
                highlightLine(2);
                await sleep();
                let key = arr[i];
                highlightLine(3);
                await sleep();
                let j = i - 1;

                highlightLine(5);
                await sleep();
                while (j >= 0 && arr[j] > key) {
                    comparisons++;
                    updateStats();
                    renderArray(arr, [j, j + 1], Array.from({ length: i }, (_, k) => k));

                    highlightLine(6);
                    await sleep();
                    arr[j + 1] = arr[j];
                    swaps++;
                    updateStats();
                    j--;
                }
                highlightLine(10);
                await sleep();
                arr[j + 1] = key;
            }
            highlightLine(null);
            renderArray(arr, [], Array.from({ length: arr.length }, (_, i) => i));
        }

        async function mergeSort(arr) {
            highlightLine(2);
            await sleep();
            await mergeSortHelper(arr, 0, arr.length - 1);
            highlightLine(null);
            renderArray(arr, [], Array.from({ length: arr.length }, (_, i) => i));
        }

        async function mergeSortHelper(arr, left, right) {
            highlightLine(4);
            await sleep();
            if (left < right) {
                highlightLine(5);
                await sleep();
                const mid = Math.floor((left + right) / 2);
                highlightLine(6);
                await sleep();
                await mergeSortHelper(arr, left, mid);
                highlightLine(7);
                await sleep();
                await mergeSortHelper(arr, mid + 1, right);
                highlightLine(9);
                await sleep();
                await merge(arr, left, mid, right);
            }
        }

        async function merge(arr, left, mid, right) {
            highlightLine(13);
            await sleep();
            const leftArr = arr.slice(left, mid + 1);
            highlightLine(14);
            await sleep();
            const rightArr = arr.slice(mid + 1, right + 1);
            highlightLine(15);
            await sleep();
            let i = 0, j = 0, k = left;

            highlightLine(17);
            await sleep();
            while (i < leftArr.length && j < rightArr.length) {
                comparisons++;
                updateStats();
                renderArray(arr, [left + i, mid + 1 + j]);

                highlightLine(18);
                await sleep();
                if (leftArr[i] <= rightArr[j]) {
                    highlightLine(19);
                    await sleep();
                    arr[k++] = leftArr[i++];
                } else {
                    highlightLine(21);
                    await sleep();
                    arr[k++] = rightArr[j++];
                }
                swaps++;
            }

            highlightLine(25);
            await sleep();
            while (i < leftArr.length) arr[k++] = leftArr[i++];
            while (j < rightArr.length) arr[k++] = rightArr[j++];
        }

        async function quickSort(arr) {
            highlightLine(2);
            await sleep();
            await quickSortHelper(arr, 0, arr.length - 1);
            highlightLine(null);
            renderArray(arr, [], Array.from({ length: arr.length }, (_, i) => i));
        }

        async function quickSortHelper(arr, low, high) {
            highlightLine(2);
            await sleep();
            if (low < high) {
                highlightLine(4);
                await sleep();
                const pi = await partition(arr, low, high);
                highlightLine(5);
                await sleep();
                await quickSortHelper(arr, low, pi - 1);
                highlightLine(6);
                await sleep();
                await quickSortHelper(arr, pi + 1, high);
            }
        }

        async function partition(arr, low, high) {
            highlightLine(4);
            await sleep();
            const pivot = arr[high];
            highlightLine(5);
            await sleep();
            let i = low - 1;

            for (let j = low; j < high; j++) {
                comparisons++;
                updateStats();
                renderArray(arr, [j, high]);
                await sleep();

                if (arr[j] < pivot) {
                    highlightLine(5);
                    await sleep();
                    i++;
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                    swaps++;
                    updateStats();
                }
            }
            highlightLine(6);
            await sleep();
            [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            swaps++;
            updateStats();
            return i + 1;
        }
    </script>
</body>
</html>
